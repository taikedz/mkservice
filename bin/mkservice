#!/bin/bash

### A utility for making systemd services Usage:help
#
# Command structure
#
# 	mkservice -s SERVICENAME -d DESCRIPTION [OPTIONS ...] -- COMMAND ...
#
# Mandatory options
# -----------------
#
# -d DESCRIPTION
# 	A short description for the service
#
# -n SERVICENAME
# 	The name of the service - this should be an alphanumeric string
#
# Additional options
# ------------------
#
# -u USERNAME
# 	The name of the user to run the service as.
# 	Default is "nobody"
#
# -r RESTARTPOLICY
# 	When to restart the service - available modes are
# 		no
# 		on-success
# 		on-failure
# 		on-abnormal
# 		on-watchdog
# 		on-abort
# 		always
# 	Default is "always"
#
# -a AFTER
# 	Set the target to start after
# 	Default is "network.target"
#
# -w WANTEDBY
# 	Set a target to start before
# 	Default is "default.target"
#
# --overwrite
# 	If the service file already exists, overwrite without prompting
#
# -f FILEPATH
# 	Choose a different destination to write the file to
#
###/doc

##bash-libs: autohelp.sh @ d4f2e817-modified

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Write your help as documentation comments in your script
#
# If you need to output the help from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script to stdout
#
# A help comment looks like this:
#
#	### <title> Usage:help
#	#
#	# <some content>
#	#
#	# end with "###/doc" on its own line (whitespaces before
#	# and after are OK)
#	#
#	###/doc
#
# You can set a different help section by specifying a subsection
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable:
#
# 	HELPCHAR=%
#
###/doc

HELPCHAR='#'

function autohelp:print {
	local SECTION_STRING="${1:-}"; shift || :
	local TARGETFILE="${1:-}"; shift || :
	[[ -n "$SECTION_STRING" ]] || SECTION_STRING=help
	[[ -n "$TARGETFILE" ]] || TARGETFILE="$0"

        echo -e "\n$(basename "$TARGETFILE")\n===\n"
        local SECSTART='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$SECTION_STRING"'\s*$'
        local SECEND='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
        local insec=false

        while read secline; do
                if [[ "$secline" =~ $SECSTART ]]; then
                        insec=true
                        echo -e "\n${BASH_REMATCH[1]}\n---\n"

                elif [[ "$insec" = true ]]; then
                        if [[ "$secline" =~ $SECEND ]]; then
                                insec=false
                        else
				echo "$secline" | sed -r "s/^\s*$HELPCHAR//g"
                        fi
                fi
        done < "$TARGETFILE"

        if [[ "$insec" = true ]]; then
                echo "WARNING: Non-terminated help block." 1>&2
        fi
	echo ""
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
function autohelp:paged {
	: ${PAGER=less}
	autohelp:print "$@" | $PAGER
}

### autohelp:check Usage:bbuild
#
# Automatically print help and exit if "--help" is detected in arguments
#
# Example use:
#
#	#!/bin/bash
#
#	### Some help Usage:help
#	#
#	# Some help text
#	#
#	###/doc
#
#	#%include autohelp.sh
#
#	main() {
#		autohelp:check "$@"
#
#		# now add your code
#	}
#
#	main "$@"
#
###/doc
autohelp:check() {
	if [[ "$*" =~ --help ]]; then
		cols="$(tput cols)"
		autohelp:print | fold -w "$cols" -s || autohelp:print
		exit 0
	fi
}

##bash-libs: out.sh @ d4f2e817-modified


### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### Environment Variables Usage:bbuild
#
# MODE_DEBUG : set to 'true' to enable debugging output
# MODE_DEBUG_VERBOSE : set to 'true' to enable command echoing
#
###/doc

: ${MODE_DEBUG=false}
: ${MODE_DEBUG_VERBOSE=false}

# Internal
function out:buffer_initialize {
	OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:debug MESSAGE Usage:bbuild
# print a blue debug message to stderr
# only prints if MODE_DEBUG is set to "true"
###/doc
function out:debug {
	if [[ "$MODE_DEBUG" = true ]]; then
		echo "${CBBLU}DEBUG: $CBLU$*$CDEF" 1>&2
	fi
}

### out:debug:fork [MARKER] Usage:bbuild
#
# Pipe the data coming through stdin to stdout
#
# If debug mode is on, *also* write the same data to stderr, each line preceded by MARKER
#
# Insert this debug fork into pipes to see their output
#
###/doc
function out:debug:fork {
	if [[ "$MODE_DEBUG" = true ]]; then
		local MARKER="${1:-DEBUG: }"; shift || :

		cat - | sed -r "s/^/$MARKER/" | tee -a /dev/stderr
	else
		cat -
	fi
}

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
	echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
	echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
	OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
	[[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

	[[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

	for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
		"$@" "$buffer_line"
	done

	out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
	local ERCODE=127
	local numpat='^[0-9]+$'

	if [[ "$1" =~ $numpat ]]; then
		ERCODE="$1"; shift || :
	fi

	echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
	exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
	echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

### out:dump Usage:bbuild
#
# Dump stdin contents to console stderr. Requires debug mode.
#
# Example
#
# 	action_command 2>&1 | out:dump
#
###/doc

function out:dump {
	echo -n "${CBPUR}$*" 1>&2
	echo -n "$CPUR" 1>&2
	cat - 1>&2
	echo -n "$CDEF" 1>&2
}

### out:break MESSAGE Usage:bbuild
#
# Add break points to a script
#
# Requires MODE_DEBUG set to true
#
# When the script runs, the message is printed with a propmt, and execution pauses.
#
# Press return to continue execution.
#
# Type `exit`, `quit` or `stop` to stop the program. If the breakpoint is in a subshell,
#  execution from after the subshell will be resumed.
#
###/doc

function out:break {
	[[ "$MODE_DEBUG" = true ]] || return 0

	echo -en "${CRED}BREAKPOINT: $* >$CDEF " >&2
	read
	if [[ "$REPLY" =~ quit|exit|stop ]]; then
		out:fail "ABORT"
	fi
}

if [[ "$MODE_DEBUG_VERBOSE" = true ]]; then
	set -x
fi
##bash-libs: colours.sh @ d4f2e817-modified

### Colours for bash Usage:bbuild
# A series of colour flags for use in outputs.
#
# Example:
# 	
# 	echo -e "${CRED}Some red text ${CBBLU} some blue text $CDEF some text in the terminal's default colour")
#
# Requires processing of escape characters.
#
# Colours available:
#
# CRED, CBRED, HLRED -- red, bold red, highlight red
# CGRN, CBGRN, HLGRN -- green, bold green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bold yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bold blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bold purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bold teal, highlight teal
#
# CDEF -- switches to the terminal default
# CUNL -- add underline
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
###/doc

export CRED=$(echo -e "\033[0;31m")
export CGRN=$(echo -e "\033[0;32m")
export CYEL=$(echo -e "\033[0;33m")
export CBLU=$(echo -e "\033[0;34m")
export CPUR=$(echo -e "\033[0;35m")
export CTEA=$(echo -e "\033[0;36m")

export CBRED=$(echo -e "\033[1;31m")
export CBGRN=$(echo -e "\033[1;32m")
export CBYEL=$(echo -e "\033[1;33m")
export CBBLU=$(echo -e "\033[1;34m")
export CBPUR=$(echo -e "\033[1;35m")
export CBTEA=$(echo -e "\033[1;36m")

export HLRED=$(echo -e "\033[41m")
export HLGRN=$(echo -e "\033[42m")
export HLYEL=$(echo -e "\033[43m")
export HLBLU=$(echo -e "\033[44m")
export HLPUR=$(echo -e "\033[45m")
export HLTEA=$(echo -e "\033[46m")

export CDEF=$(echo -e "\033[0m")
##bash-libs: askuser.sh @ d4f2e817-modified

### askuser Usage:bbuild
# Present the user with questions on stderr
###/doc


yespat='^(yes|YES|y|Y)$'
numpat='^[0-9]+$'
rangepat='[0-9]+,[0-9]+'
listpat='^[0-9 ]+$'
blankpat='^ *$'

### askuser:confirm Usage:bbuild
# Ask the user to confirm a closed question. Defaults to no
#
# returns 0 on successfully match 'y' or 'yes'
# returns 1 otherwise
###/doc
function askuser:confirm {
	read -p "$* [y/N] > " 1>&2
	if [[ "$REPLY" =~ $yespat ]]; then
		return 0
	else
		return 1
	fi
}

### askuser:ask Usage:bbuild
# Ask the user to provide some text
#
# Echoes out the entered text
###/doc
function askuser:ask {
	read -p "$* : " 1>&2
	echo "$REPLY"
}

### askuser:password Usage:bbuild
# Ask the user to enter a password (does not echo what is typed)
#
# Echoes out the entered text
###/doc
function askuser:password {
	read -s -p "$* : " 1>&2
	echo "$REPLY"
}

### askuser:choose_multi Usage:bbuild
# Allows the user to choose from multiple choices
#
# askuser:chose_multi MESG CHOICESTRING
#
#
# MESG is a single string token that will be displayed as prompt
#
# CHOICESTRING is a comma-separated, or newline separated, or "\\n"-separated token string
#
# Equivalent strings include:
#
# * `"a\\nb\\nc"` - quoted and explicit newline escapes
# * `"a,b,c"` - quoted and separated with commas
# * `a , b , c` - not quoted, separated by commas
# * `a`, `b` and `c` on their own lines
#
# User input:
#
# User can choose by selecting
#
# * a single item by number
# * a range of numbers (4,7 for range 4 to 7)
# * or a string that matches the pattern
#
# All option lines that match will be returned, one per line
#
# If the user selects nothing, then function returns 1 and an empty stdout
###/doc
function askuser:choose_multi {
	local mesg=$1; shift || :
	local choices=$(echo "$*"|sed -r 's/ *, */\n/g')
	out:debug "CHOICES: $choices"

	out:info "$mesg:" 
	local choicelist="$(echo -e "$choices"|egrep '^' -n| sed 's/:/: /')"
	echo "$choicelist" 1>&2
	
	local sel=$(askuser:ask "Choice")
	if [[ "$sel" =~ $blankpat ]]; then
		return 1

	elif [[ "$sel" =~ $numpat ]] || [[ "$sel" =~ $rangepat ]]; then
		out:debug "Number choice [$sel]"
		echo -e "$choices" | sed -n "$sel p"
	
	elif [[ "$sel" =~ $listpat ]]; then
		echo "$choicelist" | egrep "^${sel// /|}:" | sed -r 's/^[0-9]+: //'

	else
		out:debug "Pattern choice [$sel]"
		echo -e "$choices"  |egrep "$(echo "$sel"|tr " " '|')"
	fi
	return 0
}

### askuser:choose Usage:bbuild
# Ask the user to choose an item
#
# Like askuser:choose_multi, but will loop if the user selects more than one item
#
# If the user provides no entry, returns 1
#
# If the user chooses one item, that item is echoed to stdout
###/doc
function askuser:choose {
	local mesg=$1; shift || :
	while true; do
		local thechoice="$(askuser:choose_multi "$mesg" "$*")"
		local lines=$(echo -n "$thechoice" | grep '$' -c)
		if [[ $lines = 1 ]]; then
			echo "$thechoice"
			return 0
		elif [[ $lines = 0 ]]; then
			return 1
		else
			out:warn "Too many results"
		fi
	done
}
##bash-libs: varify.sh @ d4f2e817-modified

### Varify Usage:bbuild
# Make a string into a valid variable name or file name
#
# Collapses any string of invalid characters into a single underscore
#
# For example
#
# 	varify:var "http://example.com"
#
# returns
#
# 	http_example.com
#
###/doc

### varify:var Usage:bbuild
#
# Valid characters for varify:var are:
#
# * a-z
# * A-Z
# * 0-9
# * underscore ("_")
###/doc
function varify:var {
	echo "$*" | sed -r 's/[^a-zA-Z0-9_]/_/g'
}

### varify:fil Usage:bbuild
#
# Valid characters for varify:fil are:
#
# * a-z
# * A-Z
# * 0-9
# * underscore ("_")
# * dash ("-")
# * period (".")
#
# Can be used to produce filenames.
#
###/doc
function varify:fil {
	echo "$*" | sed -r 's/[^a-zA-Z0-9_.-]/_/g'
}
##bash-libs: bincheck.sh @ d4f2e817-modified

### bincheck:get COMMANDS ... Usage:bbuild
#
# Return the first existing binary
#
# Useful for finding an appropriate binary when you know
# different systems may supply binaries under different names.
#
# Returns the full path from `which` for the first executable
# encountered.
#
# Example:
#
# 	bincheck:get markdown_py markdown ./mymarkdown
#
# Tries in turn to get a `markdown_py`, then a `markdown`, and then a local `./mymarkdown`
#
###/doc

bincheck:get() {
	local BINEXE=
	for binname in "$@"; do
		# Some implementations of `which` print error messages
		# Not useful here.
		BINEXE=$(which "$binname" 2>/dev/null)

		if [[ -n "$BINEXE" ]]; then
			echo "$BINEXE"
			return 0
		fi
	done
	return 1
}

### bincheck:has NAMES ... Usage:bbuild
#
# Determine if at least one of the binaries listed is present and installed on the system
#
###/doc

bincheck:has() {
	[[ -n "$(bincheck:get "$@")" ]]
}

### bincheck:path NAME Usage:bbuild
#
# Determine the actual path to the command
#
# Relative paths are not expanded.
#
###/doc

bincheck:path() {
	local binname="$1"; shift || :

	[[ "$binname" =~ / ]] && { 
		# A relative path cannot be resolved, just check existence
		[[ -e "$binname" ]] && echo "$binname" || return 1

	} || binname="$(which "$binname" 2>/dev/null)"

	# `which` failed
	[[ -n "$binname" ]] || return 1

	[[ -h "$binname" ]] && {

		local pointedname="$(ls -l "$binname"|grep -oP "$binname.+"|sed "s|$binname -> ||")"
		bincheck:path "$pointedname" ; return "$?"
	
	} || echo "$binname"
}
##bash-libs: runmain.sh @ d4f2e817-modified

### runmain SCRIPTNAME FUNCTION [ARGUMENTS ...] Usage:bbuild
#
# Runs the function FUNCTION with ARGUMENTS, only if the runtime
# name of the script matches SCRIPTNAME
#
# This allows you include a main-like function in your library
# that only runs if you use your lib as an executabl itself.
#
# For example, an image archiver could be:
#
# 	function archive_images {
# 		tar czf "$1.tgz" "$@"
# 	}
#
# 	runmain archiveimages.sh archive_images "$@"
#
# When included a different script, the runmain call does not fire the lib's function
#
# If the lib is compiled/made executable, and named "archiveimages.sh", the function runs.
#
# This is similar to `if __name__ == "__main__"` clauses in python
#
###/doc

function runmain {
	local required_name="$1"; shift || :
	local funcall="$1"; shift || :
	local scriptname="$(basename "$0")"

	if [[ "$required_name" = "$scriptname" ]]; then
		"$funcall" "$@"
	fi
}
##bash-libs: isroot.sh @ d4f2e817-modified


### isroot Usage:bbuild
# Test for root access
#
# If using cygwin, user is always root.
###/doc

function isroot {
	[[ "$UID" = 0 ]] || isroot:cygwin
}

### isroot:cygwin Usage:bbuild
# Returns whether running under cygwin.
#
# Typically a user under cygwin is root, except when they're not
#
# This utility exists as a reminder to check for cygwin.
###/doc

function isroot:cygwin {
	uname -o | grep -i cygwin -q
}

### isroot:require MESSAGE Usage:bbuild
# Require root. If script is not running as root,
# print message and exit
###/doc
function isroot:require {
	isroot || out:fail "$*"
}

S_USER=nobody
S_RESTART=always
S_AFTER=network.target
S_WANTEDBY=default.target

S_OVERWRITE=false

parse_arguments() {
	while [[ -n "$*" ]]; do
		local token="$1"; shift

		case "$token" in
		-d)
			S_DESCRIPTION="$1"; shift
			;;
		-u)
			S_USER="$(varify_var "$1")"; shift
			;;
		-r)
			S_RESTART="$(validate_restart "$1")"
			;;
		-n)
			S_SERVICENAME="$(varify_fil "$1")"; shift
			;;
		-a)
			S_AFTER="$1"; shift
			;;
		-w)
			S_WANTEDBY="$1"; shift
			;;
		--overwrite)
			S_OVERWRITE=true
			;;
		-f)
			S_SERVICEFILE="$1"; shift
			;;
		--)
			S_COMMAND=("$@")
			return
			;;
		esac
	done
}

validate_restart() {
	local rpat="^(no|on-success|on-failure|on-abnormal|on-watchdog|on-abort|always)$"
	local rpolicy="$1"; shift

	[[ "$rpolicy" =~ $rpat ]] && echo "$rpolicy" || out:fail "Invalid restart policy $rpolicy"
}

verify_arguments() {
	( [[ -n "${S_DESCRIPTION:-}" ]] &&
	  [[ -n "${S_COMMAND:-}" ]] &&
	  [[ -n "${S_SERVICENAME:-}" ]] ) || out:fail "Not enough information. Please see 'mkservice --help' for more info"
}

stringify() {
	# Reinstate any doublequotes
	local commandstring=""

	for token in "$@"; do
		[[ "$token" =~ ' ' ]] && token='"'"$token"'"'
		commandstring="$commandstring$token "
	done
	echo "$commandstring"
}

check_bin() {
	local S_BIN="$1"; shift
	
	[[ "$S_BIN" =~ ^/ ]] || out:fail "Invalid command '$S_BIN' - use an absolute path"
	[[ -f "$S_BIN" ]] || out:fail "Invalid command '$S_BIN' - file not found"
}

write_servicefile() {
	local tmpfile="$(mktemp)"

cat <<EOF > "$tmpfile"
[Unit]

Description=$S_DESCRIPTION
After=$S_AFTER

[Service]
ExecStart=$S_COMMANDSTRING
User=$S_USER
Restart=$S_RESTART
PIDFile=/run/$S_SERVICENAME.pid

[Install]
WantedBy=$S_WANTEDBY
EOF

	mv "$tmpfile" "$S_SERVICEFILE"
	chmod 644 "$S_SERVICEFILE"
}

check_for_systemd() {
	bincheck:has systemctl || out:fail "systemd not in use"
}

makeservice() {
	set -euo pipefail

	autohelp:check "$@"

	isroot || out:fail "You need to be root to run this script"

	check_for_systemd
	parse_arguments "$@"
	verify_arguments

	S_COMMANDSTRING="$(stringify "${S_COMMAND[@]}")"
	check_bin "${S_COMMAND[0]}"

	[[ -n "${S_SERVICEFILE:-}" ]] || S_SERVICEFILE="/etc/systemd/system/$S_SERVICENAME.service"

	[[ ! -f "$S_SERVICEFILE" ]] || {
		if [[ "${S_OVERWRITE:-}" != 'true' ]]; then
			out:warn "That service already exists."
			askuser:confirm "Overwrite ?" || out:fail Aborted
		fi
	}

	write_servicefile


	out:info "Configured service $S_SERVICENAME"
	out:info "Adjust it at ${CBBLU}$S_SERVICEFILE"
	out:info "Activate it using\n\tsystemctl enable $S_SERVICENAME\n\tsystemctl start $S_SERVICENAME"
}

runmain mkservice makeservice "$@"
